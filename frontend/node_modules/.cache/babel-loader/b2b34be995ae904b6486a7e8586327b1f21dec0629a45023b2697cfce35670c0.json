{"ast":null,"code":"\"use strict\";\n\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PluggableAuthHandler = void 0;\nconst pluggable_auth_client_1 = require(\"./pluggable-auth-client\");\nconst executable_response_1 = require(\"./executable-response\");\nconst childProcess = require(\"child_process\");\nconst fs = require(\"fs\");\n/**\n * A handler used to retrieve 3rd party token responses from user defined\n * executables and cached file output for the PluggableAuthClient class.\n */\nclass PluggableAuthHandler {\n  /**\n   * Instantiates a PluggableAuthHandler instance using the provided\n   * PluggableAuthHandlerOptions object.\n   */\n  constructor(options) {\n    if (!options.command) {\n      throw new Error('No command provided.');\n    }\n    this.commandComponents = PluggableAuthHandler.parseCommand(options.command);\n    this.timeoutMillis = options.timeoutMillis;\n    if (!this.timeoutMillis) {\n      throw new Error('No timeoutMillis provided.');\n    }\n    this.outputFile = options.outputFile;\n  }\n  /**\n   * Calls user provided executable to get a 3rd party subject token and\n   * returns the response.\n   * @param envMap a Map of additional Environment Variables required for\n   *   the executable.\n   * @return A promise that resolves with the executable response.\n   */\n  retrieveResponseFromExecutable(envMap) {\n    return new Promise((resolve, reject) => {\n      // Spawn process to run executable using added environment variables.\n      const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {\n        env: {\n          ...process.env,\n          ...Object.fromEntries(envMap)\n        }\n      });\n      let output = '';\n      // Append stdout to output as executable runs.\n      child.stdout.on('data', data => {\n        output += data;\n      });\n      // Append stderr as executable runs.\n      child.stderr.on('data', err => {\n        output += err;\n      });\n      // Set up a timeout to end the child process and throw an error.\n      const timeout = setTimeout(() => {\n        // Kill child process and remove listeners so 'close' event doesn't get\n        // read after child process is killed.\n        child.removeAllListeners();\n        child.kill();\n        return reject(new Error('The executable failed to finish within the timeout specified.'));\n      }, this.timeoutMillis);\n      child.on('close', code => {\n        // Cancel timeout if executable closes before timeout is reached.\n        clearTimeout(timeout);\n        if (code === 0) {\n          // If the executable completed successfully, try to return the parsed response.\n          try {\n            const responseJson = JSON.parse(output);\n            const response = new executable_response_1.ExecutableResponse(responseJson);\n            return resolve(response);\n          } catch (error) {\n            if (error instanceof executable_response_1.ExecutableResponseError) {\n              return reject(error);\n            }\n            return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));\n          }\n        } else {\n          return reject(new pluggable_auth_client_1.ExecutableError(output, code.toString()));\n        }\n      });\n    });\n  }\n  /**\n   * Checks user provided output file for response from previous run of\n   * executable and return the response if it exists, is formatted correctly, and is not expired.\n   */\n  async retrieveCachedResponse() {\n    if (!this.outputFile || this.outputFile.length === 0) {\n      return undefined;\n    }\n    let filePath;\n    try {\n      filePath = await fs.promises.realpath(this.outputFile);\n    } catch (_a) {\n      // If file path cannot be resolved, return undefined.\n      return undefined;\n    }\n    if (!(await fs.promises.lstat(filePath)).isFile()) {\n      // If path does not lead to file, return undefined.\n      return undefined;\n    }\n    const responseString = await fs.promises.readFile(filePath, {\n      encoding: 'utf8'\n    });\n    if (responseString === '') {\n      return undefined;\n    }\n    try {\n      const responseJson = JSON.parse(responseString);\n      const response = new executable_response_1.ExecutableResponse(responseJson);\n      // Check if response is successful and unexpired.\n      if (response.isValid()) {\n        return new executable_response_1.ExecutableResponse(responseJson);\n      }\n      return undefined;\n    } catch (error) {\n      if (error instanceof executable_response_1.ExecutableResponseError) {\n        throw error;\n      }\n      throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);\n    }\n  }\n  /**\n   * Parses given command string into component array, splitting on spaces unless\n   * spaces are between quotation marks.\n   */\n  static parseCommand(command) {\n    // Split the command into components by splitting on spaces,\n    // unless spaces are contained in quotation marks.\n    const components = command.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n    if (!components) {\n      throw new Error(`Provided command: \"${command}\" could not be parsed.`);\n    }\n    // Remove quotation marks from the beginning and end of each component if they are present.\n    for (let i = 0; i < components.length; i++) {\n      if (components[i][0] === '\"' && components[i].slice(-1) === '\"') {\n        components[i] = components[i].slice(1, -1);\n      }\n    }\n    return components;\n  }\n}\nexports.PluggableAuthHandler = PluggableAuthHandler;","map":{"version":3,"names":["Object","defineProperty","exports","value","PluggableAuthHandler","pluggable_auth_client_1","require","executable_response_1","childProcess","fs","constructor","options","command","Error","commandComponents","parseCommand","timeoutMillis","outputFile","retrieveResponseFromExecutable","envMap","Promise","resolve","reject","child","spawn","slice","env","process","fromEntries","output","stdout","on","data","stderr","err","timeout","setTimeout","removeAllListeners","kill","code","clearTimeout","responseJson","JSON","parse","response","ExecutableResponse","error","ExecutableResponseError","ExecutableError","toString","retrieveCachedResponse","length","undefined","filePath","promises","realpath","_a","lstat","isFile","responseString","readFile","encoding","isValid","components","match","i"],"sources":["D:/Student_Database_IITBH/frontend/node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js"],"sourcesContent":["\"use strict\";\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PluggableAuthHandler = void 0;\nconst pluggable_auth_client_1 = require(\"./pluggable-auth-client\");\nconst executable_response_1 = require(\"./executable-response\");\nconst childProcess = require(\"child_process\");\nconst fs = require(\"fs\");\n/**\n * A handler used to retrieve 3rd party token responses from user defined\n * executables and cached file output for the PluggableAuthClient class.\n */\nclass PluggableAuthHandler {\n    /**\n     * Instantiates a PluggableAuthHandler instance using the provided\n     * PluggableAuthHandlerOptions object.\n     */\n    constructor(options) {\n        if (!options.command) {\n            throw new Error('No command provided.');\n        }\n        this.commandComponents = PluggableAuthHandler.parseCommand(options.command);\n        this.timeoutMillis = options.timeoutMillis;\n        if (!this.timeoutMillis) {\n            throw new Error('No timeoutMillis provided.');\n        }\n        this.outputFile = options.outputFile;\n    }\n    /**\n     * Calls user provided executable to get a 3rd party subject token and\n     * returns the response.\n     * @param envMap a Map of additional Environment Variables required for\n     *   the executable.\n     * @return A promise that resolves with the executable response.\n     */\n    retrieveResponseFromExecutable(envMap) {\n        return new Promise((resolve, reject) => {\n            // Spawn process to run executable using added environment variables.\n            const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {\n                env: { ...process.env, ...Object.fromEntries(envMap) },\n            });\n            let output = '';\n            // Append stdout to output as executable runs.\n            child.stdout.on('data', (data) => {\n                output += data;\n            });\n            // Append stderr as executable runs.\n            child.stderr.on('data', (err) => {\n                output += err;\n            });\n            // Set up a timeout to end the child process and throw an error.\n            const timeout = setTimeout(() => {\n                // Kill child process and remove listeners so 'close' event doesn't get\n                // read after child process is killed.\n                child.removeAllListeners();\n                child.kill();\n                return reject(new Error('The executable failed to finish within the timeout specified.'));\n            }, this.timeoutMillis);\n            child.on('close', (code) => {\n                // Cancel timeout if executable closes before timeout is reached.\n                clearTimeout(timeout);\n                if (code === 0) {\n                    // If the executable completed successfully, try to return the parsed response.\n                    try {\n                        const responseJson = JSON.parse(output);\n                        const response = new executable_response_1.ExecutableResponse(responseJson);\n                        return resolve(response);\n                    }\n                    catch (error) {\n                        if (error instanceof executable_response_1.ExecutableResponseError) {\n                            return reject(error);\n                        }\n                        return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));\n                    }\n                }\n                else {\n                    return reject(new pluggable_auth_client_1.ExecutableError(output, code.toString()));\n                }\n            });\n        });\n    }\n    /**\n     * Checks user provided output file for response from previous run of\n     * executable and return the response if it exists, is formatted correctly, and is not expired.\n     */\n    async retrieveCachedResponse() {\n        if (!this.outputFile || this.outputFile.length === 0) {\n            return undefined;\n        }\n        let filePath;\n        try {\n            filePath = await fs.promises.realpath(this.outputFile);\n        }\n        catch (_a) {\n            // If file path cannot be resolved, return undefined.\n            return undefined;\n        }\n        if (!(await fs.promises.lstat(filePath)).isFile()) {\n            // If path does not lead to file, return undefined.\n            return undefined;\n        }\n        const responseString = await fs.promises.readFile(filePath, {\n            encoding: 'utf8',\n        });\n        if (responseString === '') {\n            return undefined;\n        }\n        try {\n            const responseJson = JSON.parse(responseString);\n            const response = new executable_response_1.ExecutableResponse(responseJson);\n            // Check if response is successful and unexpired.\n            if (response.isValid()) {\n                return new executable_response_1.ExecutableResponse(responseJson);\n            }\n            return undefined;\n        }\n        catch (error) {\n            if (error instanceof executable_response_1.ExecutableResponseError) {\n                throw error;\n            }\n            throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);\n        }\n    }\n    /**\n     * Parses given command string into component array, splitting on spaces unless\n     * spaces are between quotation marks.\n     */\n    static parseCommand(command) {\n        // Split the command into components by splitting on spaces,\n        // unless spaces are contained in quotation marks.\n        const components = command.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n        if (!components) {\n            throw new Error(`Provided command: \"${command}\" could not be parsed.`);\n        }\n        // Remove quotation marks from the beginning and end of each component if they are present.\n        for (let i = 0; i < components.length; i++) {\n            if (components[i][0] === '\"' && components[i].slice(-1) === '\"') {\n                components[i] = components[i].slice(1, -1);\n            }\n        }\n        return components;\n    }\n}\nexports.PluggableAuthHandler = PluggableAuthHandler;\n//# sourceMappingURL=pluggable-auth-handler.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}