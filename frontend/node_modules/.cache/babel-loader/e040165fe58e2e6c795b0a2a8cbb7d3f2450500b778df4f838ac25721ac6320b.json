{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GoogleToken = void 0;\nconst fs = require(\"fs\");\nconst gaxios_1 = require(\"gaxios\");\nconst jws = require(\"jws\");\nconst path = require(\"path\");\nconst util_1 = require(\"util\");\nconst readFile = fs.readFile ? (0, util_1.promisify)(fs.readFile) : async () => {\n  // if running in the web-browser, fs.readFile may not have been shimmed.\n  throw new ErrorWithCode('use key rather than keyFile.', 'MISSING_CREDENTIALS');\n};\nconst GOOGLE_TOKEN_URL = 'https://www.googleapis.com/oauth2/v4/token';\nconst GOOGLE_REVOKE_TOKEN_URL = 'https://accounts.google.com/o/oauth2/revoke?token=';\nclass ErrorWithCode extends Error {\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n}\nclass GoogleToken {\n  get accessToken() {\n    return this.rawToken ? this.rawToken.access_token : undefined;\n  }\n  get idToken() {\n    return this.rawToken ? this.rawToken.id_token : undefined;\n  }\n  get tokenType() {\n    return this.rawToken ? this.rawToken.token_type : undefined;\n  }\n  get refreshToken() {\n    return this.rawToken ? this.rawToken.refresh_token : undefined;\n  }\n  /**\n   * Create a GoogleToken.\n   *\n   * @param options  Configuration object.\n   */\n  constructor(options) {\n    this.transporter = {\n      request: opts => (0, gaxios_1.request)(opts)\n    };\n    this.configure(options);\n  }\n  /**\n   * Returns whether the token has expired.\n   *\n   * @return true if the token has expired, false otherwise.\n   */\n  hasExpired() {\n    const now = new Date().getTime();\n    if (this.rawToken && this.expiresAt) {\n      return now >= this.expiresAt;\n    } else {\n      return true;\n    }\n  }\n  /**\n   * Returns whether the token will expire within eagerRefreshThresholdMillis\n   *\n   * @return true if the token will be expired within eagerRefreshThresholdMillis, false otherwise.\n   */\n  isTokenExpiring() {\n    var _a;\n    const now = new Date().getTime();\n    const eagerRefreshThresholdMillis = (_a = this.eagerRefreshThresholdMillis) !== null && _a !== void 0 ? _a : 0;\n    if (this.rawToken && this.expiresAt) {\n      return this.expiresAt <= now + eagerRefreshThresholdMillis;\n    } else {\n      return true;\n    }\n  }\n  getToken(callback, opts = {}) {\n    if (typeof callback === 'object') {\n      opts = callback;\n      callback = undefined;\n    }\n    opts = Object.assign({\n      forceRefresh: false\n    }, opts);\n    if (callback) {\n      const cb = callback;\n      this.getTokenAsync(opts).then(t => cb(null, t), callback);\n      return;\n    }\n    return this.getTokenAsync(opts);\n  }\n  /**\n   * Given a keyFile, extract the key and client email if available\n   * @param keyFile Path to a json, pem, or p12 file that contains the key.\n   * @returns an object with privateKey and clientEmail properties\n   */\n  async getCredentials(keyFile) {\n    const ext = path.extname(keyFile);\n    switch (ext) {\n      case '.json':\n        {\n          const key = await readFile(keyFile, 'utf8');\n          const body = JSON.parse(key);\n          const privateKey = body.private_key;\n          const clientEmail = body.client_email;\n          if (!privateKey || !clientEmail) {\n            throw new ErrorWithCode('private_key and client_email are required.', 'MISSING_CREDENTIALS');\n          }\n          return {\n            privateKey,\n            clientEmail\n          };\n        }\n      case '.der':\n      case '.crt':\n      case '.pem':\n        {\n          const privateKey = await readFile(keyFile, 'utf8');\n          return {\n            privateKey\n          };\n        }\n      case '.p12':\n      case '.pfx':\n        {\n          throw new ErrorWithCode('*.p12 certificates are not supported after v6.1.2. ' + 'Consider utilizing *.json format or converting *.p12 to *.pem using the OpenSSL CLI.', 'UNKNOWN_CERTIFICATE_TYPE');\n        }\n      default:\n        throw new ErrorWithCode('Unknown certificate type. Type is determined based on file extension. ' + 'Current supported extensions are *.json, and *.pem.', 'UNKNOWN_CERTIFICATE_TYPE');\n    }\n  }\n  async getTokenAsync(opts) {\n    if (this.inFlightRequest && !opts.forceRefresh) {\n      return this.inFlightRequest;\n    }\n    try {\n      return await (this.inFlightRequest = this.getTokenAsyncInner(opts));\n    } finally {\n      this.inFlightRequest = undefined;\n    }\n  }\n  async getTokenAsyncInner(opts) {\n    if (this.isTokenExpiring() === false && opts.forceRefresh === false) {\n      return Promise.resolve(this.rawToken);\n    }\n    if (!this.key && !this.keyFile) {\n      throw new Error('No key or keyFile set.');\n    }\n    if (!this.key && this.keyFile) {\n      const creds = await this.getCredentials(this.keyFile);\n      this.key = creds.privateKey;\n      this.iss = creds.clientEmail || this.iss;\n      if (!creds.clientEmail) {\n        this.ensureEmail();\n      }\n    }\n    return this.requestToken();\n  }\n  ensureEmail() {\n    if (!this.iss) {\n      throw new ErrorWithCode('email is required.', 'MISSING_CREDENTIALS');\n    }\n  }\n  revokeToken(callback) {\n    if (callback) {\n      this.revokeTokenAsync().then(() => callback(), callback);\n      return;\n    }\n    return this.revokeTokenAsync();\n  }\n  async revokeTokenAsync() {\n    if (!this.accessToken) {\n      throw new Error('No token to revoke.');\n    }\n    const url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;\n    await this.transporter.request({\n      url\n    });\n    this.configure({\n      email: this.iss,\n      sub: this.sub,\n      key: this.key,\n      keyFile: this.keyFile,\n      scope: this.scope,\n      additionalClaims: this.additionalClaims\n    });\n  }\n  /**\n   * Configure the GoogleToken for re-use.\n   * @param  {object} options Configuration object.\n   */\n  configure(options = {}) {\n    this.keyFile = options.keyFile;\n    this.key = options.key;\n    this.rawToken = undefined;\n    this.iss = options.email || options.iss;\n    this.sub = options.sub;\n    this.additionalClaims = options.additionalClaims;\n    if (typeof options.scope === 'object') {\n      this.scope = options.scope.join(' ');\n    } else {\n      this.scope = options.scope;\n    }\n    this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;\n    if (options.transporter) {\n      this.transporter = options.transporter;\n    }\n  }\n  /**\n   * Request the token from Google.\n   */\n  async requestToken() {\n    var _a, _b;\n    const iat = Math.floor(new Date().getTime() / 1000);\n    const additionalClaims = this.additionalClaims || {};\n    const payload = Object.assign({\n      iss: this.iss,\n      scope: this.scope,\n      aud: GOOGLE_TOKEN_URL,\n      exp: iat + 3600,\n      iat,\n      sub: this.sub\n    }, additionalClaims);\n    const signedJWT = jws.sign({\n      header: {\n        alg: 'RS256'\n      },\n      payload,\n      secret: this.key\n    });\n    try {\n      const r = await this.transporter.request({\n        method: 'POST',\n        url: GOOGLE_TOKEN_URL,\n        data: {\n          grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n          assertion: signedJWT\n        },\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        responseType: 'json'\n      });\n      this.rawToken = r.data;\n      this.expiresAt = r.data.expires_in === null || r.data.expires_in === undefined ? undefined : (iat + r.data.expires_in) * 1000;\n      return this.rawToken;\n    } catch (e) {\n      this.rawToken = undefined;\n      this.tokenExpires = undefined;\n      const body = e.response && ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) ? (_b = e.response) === null || _b === void 0 ? void 0 : _b.data : {};\n      if (body.error) {\n        const desc = body.error_description ? `: ${body.error_description}` : '';\n        e.message = `${body.error}${desc}`;\n      }\n      throw e;\n    }\n  }\n}\nexports.GoogleToken = GoogleToken;","map":{"version":3,"names":["Object","defineProperty","exports","value","GoogleToken","fs","require","gaxios_1","jws","path","util_1","readFile","promisify","ErrorWithCode","GOOGLE_TOKEN_URL","GOOGLE_REVOKE_TOKEN_URL","Error","constructor","message","code","accessToken","rawToken","access_token","undefined","idToken","id_token","tokenType","token_type","refreshToken","refresh_token","options","transporter","request","opts","configure","hasExpired","now","Date","getTime","expiresAt","isTokenExpiring","_a","eagerRefreshThresholdMillis","getToken","callback","assign","forceRefresh","cb","getTokenAsync","then","t","getCredentials","keyFile","ext","extname","key","body","JSON","parse","privateKey","private_key","clientEmail","client_email","inFlightRequest","getTokenAsyncInner","Promise","resolve","creds","iss","ensureEmail","requestToken","revokeToken","revokeTokenAsync","url","email","sub","scope","additionalClaims","join","_b","iat","Math","floor","payload","aud","exp","signedJWT","sign","header","alg","secret","r","method","data","grant_type","assertion","headers","responseType","expires_in","e","tokenExpires","response","error","desc","error_description"],"sources":["D:/Student_Database_IITBH/frontend/node_modules/gtoken/build/src/index.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GoogleToken = void 0;\nconst fs = require(\"fs\");\nconst gaxios_1 = require(\"gaxios\");\nconst jws = require(\"jws\");\nconst path = require(\"path\");\nconst util_1 = require(\"util\");\nconst readFile = fs.readFile\n    ? (0, util_1.promisify)(fs.readFile)\n    : async () => {\n        // if running in the web-browser, fs.readFile may not have been shimmed.\n        throw new ErrorWithCode('use key rather than keyFile.', 'MISSING_CREDENTIALS');\n    };\nconst GOOGLE_TOKEN_URL = 'https://www.googleapis.com/oauth2/v4/token';\nconst GOOGLE_REVOKE_TOKEN_URL = 'https://accounts.google.com/o/oauth2/revoke?token=';\nclass ErrorWithCode extends Error {\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\nclass GoogleToken {\n    get accessToken() {\n        return this.rawToken ? this.rawToken.access_token : undefined;\n    }\n    get idToken() {\n        return this.rawToken ? this.rawToken.id_token : undefined;\n    }\n    get tokenType() {\n        return this.rawToken ? this.rawToken.token_type : undefined;\n    }\n    get refreshToken() {\n        return this.rawToken ? this.rawToken.refresh_token : undefined;\n    }\n    /**\n     * Create a GoogleToken.\n     *\n     * @param options  Configuration object.\n     */\n    constructor(options) {\n        this.transporter = {\n            request: opts => (0, gaxios_1.request)(opts),\n        };\n        this.configure(options);\n    }\n    /**\n     * Returns whether the token has expired.\n     *\n     * @return true if the token has expired, false otherwise.\n     */\n    hasExpired() {\n        const now = new Date().getTime();\n        if (this.rawToken && this.expiresAt) {\n            return now >= this.expiresAt;\n        }\n        else {\n            return true;\n        }\n    }\n    /**\n     * Returns whether the token will expire within eagerRefreshThresholdMillis\n     *\n     * @return true if the token will be expired within eagerRefreshThresholdMillis, false otherwise.\n     */\n    isTokenExpiring() {\n        var _a;\n        const now = new Date().getTime();\n        const eagerRefreshThresholdMillis = (_a = this.eagerRefreshThresholdMillis) !== null && _a !== void 0 ? _a : 0;\n        if (this.rawToken && this.expiresAt) {\n            return this.expiresAt <= now + eagerRefreshThresholdMillis;\n        }\n        else {\n            return true;\n        }\n    }\n    getToken(callback, opts = {}) {\n        if (typeof callback === 'object') {\n            opts = callback;\n            callback = undefined;\n        }\n        opts = Object.assign({\n            forceRefresh: false,\n        }, opts);\n        if (callback) {\n            const cb = callback;\n            this.getTokenAsync(opts).then(t => cb(null, t), callback);\n            return;\n        }\n        return this.getTokenAsync(opts);\n    }\n    /**\n     * Given a keyFile, extract the key and client email if available\n     * @param keyFile Path to a json, pem, or p12 file that contains the key.\n     * @returns an object with privateKey and clientEmail properties\n     */\n    async getCredentials(keyFile) {\n        const ext = path.extname(keyFile);\n        switch (ext) {\n            case '.json': {\n                const key = await readFile(keyFile, 'utf8');\n                const body = JSON.parse(key);\n                const privateKey = body.private_key;\n                const clientEmail = body.client_email;\n                if (!privateKey || !clientEmail) {\n                    throw new ErrorWithCode('private_key and client_email are required.', 'MISSING_CREDENTIALS');\n                }\n                return { privateKey, clientEmail };\n            }\n            case '.der':\n            case '.crt':\n            case '.pem': {\n                const privateKey = await readFile(keyFile, 'utf8');\n                return { privateKey };\n            }\n            case '.p12':\n            case '.pfx': {\n                throw new ErrorWithCode('*.p12 certificates are not supported after v6.1.2. ' +\n                    'Consider utilizing *.json format or converting *.p12 to *.pem using the OpenSSL CLI.', 'UNKNOWN_CERTIFICATE_TYPE');\n            }\n            default:\n                throw new ErrorWithCode('Unknown certificate type. Type is determined based on file extension. ' +\n                    'Current supported extensions are *.json, and *.pem.', 'UNKNOWN_CERTIFICATE_TYPE');\n        }\n    }\n    async getTokenAsync(opts) {\n        if (this.inFlightRequest && !opts.forceRefresh) {\n            return this.inFlightRequest;\n        }\n        try {\n            return await (this.inFlightRequest = this.getTokenAsyncInner(opts));\n        }\n        finally {\n            this.inFlightRequest = undefined;\n        }\n    }\n    async getTokenAsyncInner(opts) {\n        if (this.isTokenExpiring() === false && opts.forceRefresh === false) {\n            return Promise.resolve(this.rawToken);\n        }\n        if (!this.key && !this.keyFile) {\n            throw new Error('No key or keyFile set.');\n        }\n        if (!this.key && this.keyFile) {\n            const creds = await this.getCredentials(this.keyFile);\n            this.key = creds.privateKey;\n            this.iss = creds.clientEmail || this.iss;\n            if (!creds.clientEmail) {\n                this.ensureEmail();\n            }\n        }\n        return this.requestToken();\n    }\n    ensureEmail() {\n        if (!this.iss) {\n            throw new ErrorWithCode('email is required.', 'MISSING_CREDENTIALS');\n        }\n    }\n    revokeToken(callback) {\n        if (callback) {\n            this.revokeTokenAsync().then(() => callback(), callback);\n            return;\n        }\n        return this.revokeTokenAsync();\n    }\n    async revokeTokenAsync() {\n        if (!this.accessToken) {\n            throw new Error('No token to revoke.');\n        }\n        const url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;\n        await this.transporter.request({ url });\n        this.configure({\n            email: this.iss,\n            sub: this.sub,\n            key: this.key,\n            keyFile: this.keyFile,\n            scope: this.scope,\n            additionalClaims: this.additionalClaims,\n        });\n    }\n    /**\n     * Configure the GoogleToken for re-use.\n     * @param  {object} options Configuration object.\n     */\n    configure(options = {}) {\n        this.keyFile = options.keyFile;\n        this.key = options.key;\n        this.rawToken = undefined;\n        this.iss = options.email || options.iss;\n        this.sub = options.sub;\n        this.additionalClaims = options.additionalClaims;\n        if (typeof options.scope === 'object') {\n            this.scope = options.scope.join(' ');\n        }\n        else {\n            this.scope = options.scope;\n        }\n        this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;\n        if (options.transporter) {\n            this.transporter = options.transporter;\n        }\n    }\n    /**\n     * Request the token from Google.\n     */\n    async requestToken() {\n        var _a, _b;\n        const iat = Math.floor(new Date().getTime() / 1000);\n        const additionalClaims = this.additionalClaims || {};\n        const payload = Object.assign({\n            iss: this.iss,\n            scope: this.scope,\n            aud: GOOGLE_TOKEN_URL,\n            exp: iat + 3600,\n            iat,\n            sub: this.sub,\n        }, additionalClaims);\n        const signedJWT = jws.sign({\n            header: { alg: 'RS256' },\n            payload,\n            secret: this.key,\n        });\n        try {\n            const r = await this.transporter.request({\n                method: 'POST',\n                url: GOOGLE_TOKEN_URL,\n                data: {\n                    grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                    assertion: signedJWT,\n                },\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n                responseType: 'json',\n            });\n            this.rawToken = r.data;\n            this.expiresAt =\n                r.data.expires_in === null || r.data.expires_in === undefined\n                    ? undefined\n                    : (iat + r.data.expires_in) * 1000;\n            return this.rawToken;\n        }\n        catch (e) {\n            this.rawToken = undefined;\n            this.tokenExpires = undefined;\n            const body = e.response && ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data)\n                ? (_b = e.response) === null || _b === void 0 ? void 0 : _b.data\n                : {};\n            if (body.error) {\n                const desc = body.error_description\n                    ? `: ${body.error_description}`\n                    : '';\n                e.message = `${body.error}${desc}`;\n            }\n            throw e;\n        }\n    }\n}\nexports.GoogleToken = GoogleToken;\n//# sourceMappingURL=index.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}